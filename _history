{"entries":[{"timestamp":1737377178732,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":37},{"diffs":[[0,"art\""],[-1," x=\"20\" y=\"20\""],[0,"></b"]],"start1":67,"start2":67,"length1":22,"length2":8},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," x=\"225\" y=\"20\""],[0,"></b"]],"start1":107,"start2":107,"length1":23,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"preferredEditor\": \"blocksprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":228,"start2":228,"length1":36,"length2":31}]}]},{"timestamp":1737377186239,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[1,"2"],[0,"0\" y=\""],[1,"2"],[0,"0\"><"]],"start1":104,"start2":104,"length1":14,"length2":16},{"diffs":[[0,"x=\"2"],[-1,"0"],[1,"2"],[0,"5\" y=\""],[1,"2"],[0,"0\"><"]],"start1":156,"start2":156,"length1":15,"length2":16}]}]},{"timestamp":1737378306909,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"vdr_esp8286_wifi\": \"github:du-man-net/vdr_esp8286_wifi#v0.0.1\""],[0,"\n   "]],"start1":131,"start2":131,"length1":81,"length2":8}]}]},{"timestamp":1737381120451,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":316,"start2":316,"length1":17,"length2":21}]}]},{"timestamp":1737381624032,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"><block "],[1,"type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block "],[0,"type=\"de"]],"start1":77,"start2":77,"length1":16,"length2":63},{"diffs":[[0,"=\"20"],[1,"5"],[0,"\" y=\""],[-1,"2"],[0,"0\"><"]],"start1":155,"start2":155,"length1":14,"length2":14}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"ne\": \"*\""],[1,",\n        \"vdr_esp8286_wifi\": \"github:du-man-net/vdr_esp8286_wifi#v0.0.1\""],[0,"\n    },\n"]],"start1":127,"start2":127,"length1":16,"length2":89},{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":316,"start2":316,"length1":21,"length2":17}]}]},{"timestamp":1737381706856,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"vdr_esp8286_wifi\": \"github:du-man-net/vdr_esp8286_wifi#v0.0.1\""],[0,"\n   "]],"start1":131,"start2":131,"length1":81,"length2":8}]}]},{"timestamp":1737384257670,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[1,"2"],[0,"0\" y=\""],[1,"2"],[0,"0\"><"]],"start1":106,"start2":106,"length1":14,"length2":16}]}]},{"timestamp":1737384260365,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":316,"start2":316,"length1":17,"length2":21}]}]},{"timestamp":1737384278445,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"ne\": \"*\""],[1,",\n        \"vdr_esp8286_wifi\": \"github:du-man-net/vdr_esp8286_wifi#v0.0.1\""],[0,"\n    },\n"]],"start1":127,"start2":127,"length1":16,"length2":89}]}]},{"timestamp":1737385001817,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n})\n"],[-1,";,n;,n;,"]],"start1":29,"start2":29,"length1":12,"length2":4}]}]},{"timestamp":1737385030653,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"ver\""],[-1," id=\"p^40mSA}_U~1Eys)X;!g\""],[0," x=\""]],"start1":102,"start2":102,"length1":34,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"//% weight=10 color=#ff8000 icon=\"\\uf1eb\" block=\"vdr ESP8266 WiFi\"\nnamespace vdr_ESP8286_wifi {\n    // Flag to indicate whether the ESP8266 was initialized successfully.\n    let VDResp8266Initialized = false\n\n    // Buffer for data received from UART.\n    let VDRrxData = \"\"\n\n\n\n    /**\n     * Send AT command and wait for response.\n     * Return true if expected response is received.\n     * @param command The AT command without the CRLF.\n     * @param expected_response Wait for this response.\n     * @param timeout Timeout in milliseconds.\n     */\n    //% blockHidden=true\n    //% blockId=vdr_esp8266_send_command\n    export function VDRsendCommand(command: string, expected_response: string = null, timeout: number = 100): boolean {\n        // Wait a while from previous command.\n        basic.pause(10)\n\n        // Flush the Rx buffer.\n        serial.readString()\n        VDRrxData = \"\"\n\n        // Send the command and end with \"\\r\\n\".\n        serial.writeString(command + \"\\r\\n\")\n\n        // Don't check if expected response is not specified.\n        if (expected_response == null) {\n            return true\n        }\n\n        // Wait and verify the response.\n        let result = false\n        let timestamp = input.runningTime()\n        while (true) {\n            // Timeout.\n            if (input.runningTime() - timestamp > timeout) {\n                result = false\n                break\n            }\n\n            // Read until the end of the line.\n            VDRrxData += serial.readString()\n            if (VDRrxData.includes(\"\\r\\n\")) {\n                // Check if expected response received.\n                if (VDRrxData.slice(0, VDRrxData.indexOf(\"\\r\\n\")).includes(expected_response)) {\n                    result = true\n                    break\n                }\n\n                // If we expected \"OK\" but \"ERROR\" is received, do not wait for timeout.\n                if (expected_response == \"OK\") {\n                    if (VDRrxData.slice(0, VDRrxData.indexOf(\"\\r\\n\")).includes(\"ERROR\")) {\n                        result = false\n                        break\n                    }\n                }\n\n                // Trim the Rx data before loop again.\n                VDRrxData = VDRrxData.slice(VDRrxData.indexOf(\"\\r\\n\") + 2)\n            }\n        }\n\n        return result\n    }\n\n\n\n    /**\n     * Get the specific response from ESP8266.\n     * Return the line start with the specific response.\n     * @param command The specific response we want to get.\n     * @param timeout Timeout in milliseconds.\n     */\n    //% blockHidden=true\n    //% blockId=vdr_esp8266_get_response\n    export function VDRgetResponse(response: string, timeout: number = 100): string {\n        let responseLine = \"\"\n        let timestamp2 = input.runningTime()\n        while (true) {\n            // Timeout.\n            if (input.runningTime() - timestamp2 > timeout) {\n                // Check if expected response received in case no CRLF received.\n                if (VDRrxData.includes(response)) {\n                    responseLine = VDRrxData\n                }\n                break\n            }\n\n            // Read until the end of the line.\n            VDRrxData += serial.readString()\n            if (VDRrxData.includes(\"\\r\\n\")) {\n                // Check if expected response received.\n                if (VDRrxData.slice(0, VDRrxData.indexOf(\"\\r\\n\")).includes(response)) {\n                    responseLine = VDRrxData.slice(0, VDRrxData.indexOf(\"\\r\\n\"))\n\n                    // Trim the Rx data for next call.\n                    VDRrxData = VDRrxData.slice(VDRrxData.indexOf(\"\\r\\n\") + 2)\n                    break\n                }\n\n                // Trim the Rx data before loop again.\n                VDRrxData = VDRrxData.slice(VDRrxData.indexOf(\"\\r\\n\") + 2)\n            }\n        }\n\n        return responseLine\n    }\n\n\n\n    /**\n     * Format the encoding of special characters in the url.\n     * @param url The url that we want to format.\n     */\n    //% blockHidden=true\n    //% blockId=VDResp8266_format_url\n    export function VDRformatUrl(url: string): string {\n        url = url.replaceAll(\"%\", \"%25\")\n        url = url.replaceAll(\" \", \"%20\")\n        url = url.replaceAll(\"!\", \"%21\")\n        url = url.replaceAll(\"\\\"\", \"%22\")\n        url = url.replaceAll(\"#\", \"%23\")\n        url = url.replaceAll(\"$\", \"%24\")\n        url = url.replaceAll(\"&\", \"%26\")\n        url = url.replaceAll(\"'\", \"%27\")\n        url = url.replaceAll(\"(\", \"%28\")\n        url = url.replaceAll(\")\", \"%29\")\n        url = url.replaceAll(\"*\", \"%2A\")\n        url = url.replaceAll(\"+\", \"%2B\")\n        url = url.replaceAll(\",\", \"%2C\")\n        url = url.replaceAll(\"-\", \"%2D\")\n        url = url.replaceAll(\".\", \"%2E\")\n        url = url.replaceAll(\"/\", \"%2F\")\n        url = url.replaceAll(\":\", \"%3A\")\n        url = url.replaceAll(\";\", \"%3B\")\n        url = url.replaceAll(\"<\", \"%3C\")\n        url = url.replaceAll(\"=\", \"%3D\")\n        url = url.replaceAll(\">\", \"%3E\")\n        url = url.replaceAll(\"?\", \"%3F\")\n        url = url.replaceAll(\"@\", \"%40\")\n        url = url.replaceAll(\"[\", \"%5B\")\n        url = url.replaceAll(\"\\\\\", \"%5C\")\n        url = url.replaceAll(\"]\", \"%5D\")\n        url = url.replaceAll(\"^\", \"%5E\")\n        url = url.replaceAll(\"_\", \"%5F\")\n        url = url.replaceAll(\"`\", \"%60\")\n        url = url.replaceAll(\"{\", \"%7B\")\n        url = url.replaceAll(\"|\", \"%7C\")\n        url = url.replaceAll(\"}\", \"%7D\")\n        url = url.replaceAll(\"~\", \"%7E\")\n        return url\n    }\n\n\n\n    /**\n     * Return true if the ESP8266 is already initialized.\n     */\n    //% weight=30\n    //% blockGap=8\n    //% blockId=vdr_esp8266_is_esp8266_initialized\n    //% block=\"ESP8266 initialized\"\n    export function isVDRESP8266Initialized(): boolean {\n        return VDResp8266Initialized\n    }\n\n\n\n    /**\n     * Initialize the ESP8266.\n     * @param tx Tx pin of micro:bit. eg: SerialPin.P16\n     * @param rx Rx pin of micro:bit. eg: SerialPin.P15\n     * @param baudrate UART baudrate. eg: BaudRate.BaudRate115200\n     */\n    //% weight=29\n    //% blockGap=40\n    //% blockId=vdr_esp8266_init\n    //% block=\"initialize ESP8266: Tx %tx Rx %rx Baudrate %baudrate\"\n    export function VDRinit(tx: SerialPin, rx: SerialPin, baudrate: BaudRate) {\n        // Redirect the serial port.\n        serial.redirect(tx, rx, baudrate)\n        serial.setTxBufferSize(128)\n        serial.setRxBufferSize(128)\n\n        // Reset the flag.\n        VDResp8266Initialized = false\n\n        // Restore the ESP8266 factory settings.\n        if (VDRsendCommand(\"AT+RESTORE\", \"ready\", 5000) == false) return\n\n        // Turn off echo.\n        if (VDRsendCommand(\"ATE0\", \"OK\") == false) return\n\n        // Initialized successfully.\n        // Set the flag.\n        VDResp8266Initialized = true\n    }\n\n\n\n    /**\n     * Return true if the ESP8266 is connected to WiFi router.\n     */\n    //% weight=28\n    //% blockGap=8\n    //% blockId=vdr_esp8266_is_wifi_connected\n    //% block=\"WiFi connected\"\n    export function isVDRWifiConnected(): boolean {\n        // Get the connection status.\n        VDRsendCommand(\"AT+CIPSTATUS\")\n        let status = VDRgetResponse(\"STATUS:\", 1000)\n\n        // Wait until OK is received.\n        VDRgetResponse(\"OK\")\n\n        // Return the WiFi status.\n        if ((status == \"\") || status.includes(\"STATUS:5\")) {\n            return false\n        }\n        else {\n            return true\n        }\n    }\n\n\n\n    /**\n     * Connect to WiFi router.\n     * @param ssid Your WiFi SSID.\n     * @param password Your WiFi password.\n     */\n    //% weight=27\n    //% blockGap=40\n    //% blockId=vdr_esp8266_connect_wifi\n    //% block=\"connect to WiFi: SSID %ssid Password %password\"\n    export function VDRconnectWiFi(ssid: string, password: string) {\n        // Set to station mode.\n        VDRsendCommand(\"AT+CWMODE=1\", \"OK\")\n\n        // Connect to WiFi router.\n        VDRsendCommand(\"AT+CWJAP=\\\"\" + ssid + \"\\\",\\\"\" + password + \"\\\"\", \"OK\", 20000)\n    }\n\n\n    // Flag to indicate whether the data was uploaded to ThingSpeak successfully.\n    let VDRdatasUploaded = false\n\n\n\n    //% weight=26\n    //% blockGap=8\n    //% blockId=vdr_esp8266_is_datas_uploaded\n    //% block=\"Donnée envoyée\"\n    export function isChronoVDRdatasUploaded(): boolean {\n        return VDRdatasUploaded\n    }\n\n    //% weight=25\n    //% blockGap=8\n    //% blockId=vdr_esp8266_datas_upload\n    //% block=\"Connecter au serveur : Serveur %server Port %port Url %url Champs %champs\"\n    export function VDRuploadDatas(server: string,\n        port: string,\n        url: string,\n        champs: string) {\n\n        // Reset the upload successful flag.\n        VDRdatasUploaded = false\n\n        // Make sure the WiFi is connected.\n        if (isVDRWifiConnected() == false) return\n\n        // Connect to the serveur\n        if (VDRsendCommand(\"AT+CIPSTART=\\\"TCP\\\",\\\"\" + server + \"\\\",\" + port, \"OK\", 10000) == false) return\n\n        // Construct the data to send.\n\n        let data = \"GET /\" + url + \"?\" + champs;\n\n        // Send the data.\n        VDRsendCommand(\"AT+CIPSEND=\" + (data.length + 2))\n        VDRsendCommand(data)\n\n        // Return if \"SEND OK\" is not received.\n        if (VDRgetResponse(\"SEND OK\", 1000) == \"\") return\n\n        // Check the response from ThingSpeak.\n        let response = VDRgetResponse(\"+IPD\", 1000)\n        if (response == \"\") return\n\n        // Trim the response to get the upload count.\n        response = response.slice(response.indexOf(\":\") + 1, response.indexOf(\"CLOSED\"))\n        let uploadCount = parseInt(response)\n\n        // Return if upload count is 0.\n        if (uploadCount == 0) return\n\n        // Set the upload successful flag and return.\n        VDRdatasUploaded = true\n        return\n\n    }\n}\n"],[1,"basic.forever(function () {\n\t\n})\n;,n;,n;,"]],"start1":0,"start2":0,"length1":9681,"length2":41}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":223,"start2":223,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// les tests vont ici ; cela ne sera pas compilé si ce paquet est utilisé en tant qu'extension.\n"}]}],"snapshots":[{"timestamp":1737377178731,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1737381120433,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"","README.md":"","pxt.json":"{\n    \"name\": \"test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1737384257644,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"20\" y=\"20\"></block></xml>","main.ts":"","README.md":"","pxt.json":"{\n    \"name\": \"test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"}}],"shares":[],"lastSaveTime":1737385591359}